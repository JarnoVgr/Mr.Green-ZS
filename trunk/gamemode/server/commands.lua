-- © Limetric Studios ( www.limetricstudios.com ) -- All rights reserved.
-- See LICENSE.txt for license information

local table = table
local math = math
local string = string
local util = util
local pairs = pairs
local team = team
local player = player
local timer = timer
local umsg = umsg

function SendMapList ( pl,commandName,args )
	if MapCycle == nil then return end

	local x = 1
	for k, v in pairs( MapCycle ) do	
		umsg.Start( "RcMapList", pl )
			umsg.Short( x )
			umsg.String( v.Map )
		umsg.End()
		x = x + 1
	end
	
end
concommand.Add("get_maplist",SendMapList) 

function SendScoreData(pl,commandName,args)
	if not args[1] then return end
	
	local from = GetPlayerByUserID( tonumber( args[1] ) )
	if from and from:IsValid() then
		stats.SendRecordsData( from, pl )
	end
	
end
concommand.Add("get_playerstats",SendScoreData) 

function SendServerDataToPL(pl,commandName,args)
	SendServerData( pl )
end
concommand.Add("get_serverstats",SendServerDataToPL) 

function PrintMapCycle( pl,commandName,args )

	for k, v in pairs( MapCycle ) do
		pl:PrintMessage( HUD_PRINTCONSOLE,k..": "..v.Map.."\n" )
	end
	pl:PrintMessage( HUD_PRINTTALK,"The mapcycle has been printed in console" )
	
end
concommand.Add("zs_print_mapcycle",PrintMapCycle) 

function OpenBugPanel(pl, cmd, args)
	if not ValidEntity (pl) then return end
	if pl:Team() == TEAM_SPECTATOR then return end
	
	umsg.Start ("DoBugReportPanel", pl)
	umsg.End()
end
concommand.Add ("open_bugpanel", OpenBugPanel)

function SetAutoRedeem(pl,commandName,args)
	if not args[1] then return end
	pl.AutoRedeem = util.tobool(args[1])
end
concommand.Add("zs_setautoredeem",SetAutoRedeem) 

function DropWeapon(pl, commandName, args)
	if pl:GetActiveWeapon() == NULL then
		return false
	end
	
	local Weapon = pl:GetActiveWeapon()
	local wepname = Weapon:GetClass()
	
	local PlayerWeapons = pl:GetWeapons()
	local Count = 0
	for k,v in pairs ( GAMEMODE.HumanWeapons ) do
		if not v.Restricted then
			if v.Type ~= "admin" then
				if pl:HasWeapon(k) then
					Count = Count + 1
				end
			end
		end
	end
	
	-- you can't drop all of them!
	--[[if Count == 1 then
		pl:ChatPrint("You can't drop all of your weapons!")
		return false
	end]]

	--
	if Count == 1 then
		GAMEMODE:SetPlayerSpeed(pl, 210)
	end
	
	if string.sub( wepname,1,5 ) == "admin" or wepname == "weapon_zs_fists" or wepname == "weapon_frag" or wepname == "weapon_zs_punch" or wepname == "weapon_physcannon" or wepname == "weapon_physgun" or wepname == "christmas_snowball" then
		pl:ChatPrint("You're not allowed to drop this weapon.")
		return false
	end
	
	-- Save ammo information from weapon
	if GetWeaponCategory(Weapon:GetClass()) ~= "Melee" then
		Weapon.Primary.RemainingAmmo = Weapon:Clip1()
		Weapon.Primary.Magazine = pl:GetAmmoCount(Weapon:GetPrimaryAmmoTypeString())
	end
	
	--
	if GetWeaponCategory(Weapon:GetClass()) == "Tool1" or GetWeaponCategory(Weapon:GetClass()) == "Tool2" then
		Weapon.Ammunition = Weapon:Clip1()
		if wepname == "weapon_zs_medkit" then
			Weapon.RemainingAmmunition = pl:GetAmmoCount(Weapon:GetPrimaryAmmoTypeString())
		end
	end
	
	-- Drop the weapon and check to see if you can before.
	if not pl:CanDropWeapon(Weapon) then
		pl:ChatPrint("You can't drop your weapon inside objects.")
		return false
	end

	--Actual dropping
	pl:DropWeapon(Weapon)
	
	--Notify 
	--pl:ChatPrint( "You've dropped a "..tostring ( GAMEMODE.HumanWeapons[wepname].Name ) )
end
concommand.Add( "zs_dropweapon",DropWeapon ) 

local locpath = "zslocations/".. game.GetMap() ..".txt"
local locammount = 0
function SaveLocation(pl,commandName,args)
	if pl:IsAdmin() == false then return end
	local content = "-- File generated by the Mr. Green ZS location saver\n-- mrgreengaming.com"
	if file.Exists(locpath) then
		content = file.Read(locpath)
	end
	local playerpos = pl:GetPos()
	content = content .."\n\n-- Added by ".. pl:GetName()
	content = content .."\ntable.Add(DropPointsX,\"".. tostring(playerpos.x) .."\") -- PosX"
	content = content .."\ntable.Add(DropPointsY,\"".. tostring(playerpos.y) .."\") -- PosY"
	content = content .."\ntable.Add(DropPointsZ,\"".. tostring(playerpos.z) .."\") -- PosZ"
    file.Write(locpath, content)
	local ent = ents.Create("prop_dynamic")
	if ent:IsValid() then
		ent:SetModel(Model("models/weapons/w_crowbar.mdl"))
		ent:SetPos(playerpos)
		ent:Spawn()
	end
	locammount = locammount+1
	pl:ChatPrint("Location saved on server (no. ".. locammount ..").")
end
concommand.Add("zs_savelocation",SaveLocation)

function AmmountLocations(pl,commandName,args)
	if pl:IsAdmin() == false then return end
	pl:ChatPrint("Ammount of locations created this round: ".. locammount)
end
concommand.Add("zs_locammount",AmmountLocations)

function PrintZSStats(ply,commandName,args)
	ply:PrintMessage(HUD_PRINTCONSOLE,"--- Zombie Survival user stats ---")
	for k, pl in pairs(player.GetAll()) do
		if pl:Team() == TEAM_UNDEAD or pl:Team() == TEAM_HUMAN then
			ply:PrintMessage(HUD_PRINTCONSOLE,"UserID: "..pl:UserID()..";  Name: "..pl:Name()..";  SteamID: "..pl:SteamID())
			ply:PrintMessage(HUD_PRINTCONSOLE,"VoiceSet: "..pl.VoiceSet..";  Model: "..pl:GetModel())
			ply:PrintMessage(HUD_PRINTCONSOLE,"Zombies killed: "..pl.ZombiesKilled..";  Humans killed: "..pl.BrainsEaten)
			ply:PrintMessage(HUD_PRINTCONSOLE,"Redeems: "..pl.Redeems..";  Hornyness: "..pl.Hornyness)
			ply:PrintMessage(HUD_PRINTCONSOLE,"------")
		end
	end
end
concommand.Add("status_zs",PrintZSStats)

function ForceSpawnBoss(pl,commandName,args)

	if not ValidEntity(pl) then return end
	if not pl:IsSuperAdmin() then return end
	
	BOSS_TOTAL_PLAYERS_REQUIRED = 12
	BOSS_INFLICTION_REQUIRED = 100
	
end
concommand.Add("mrgreen_forceboss",ForceSpawnBoss)

function FunCommand1(pl,commandName,args)

	if not ValidEntity(pl) then return end
	if not pl:IsSuperAdmin() then return end
	
	local ent = pl:GetEyeTrace().Entity
	
	if not ValidEntity(ent) or not ent:IsPlayer() then
		ent = pl
	end
	
	umsg.Start("Fun1")
		umsg.Entity(ent or pl)
		umsg.Short(tonumber(args[1] or 1))
	umsg.End()
	
end
concommand.Add("mrgreen_fun1",FunCommand1)


-- Hats
function SetPlayerHat(pl,commandName,args)
	
	local h = args[1]
	local temp = {}
	
	if h then
		for k,hat in pairs(string.Explode("$",h)) do
			local itemID = util.GetItemID( hat )
			
			if hats[hat] and pl:Team() == TEAM_HUMAN 
			and pl:GetItemsDataTable()[itemID] and (not shopData[itemID].AdminOnly or pl:IsAdmin()) then
				table.insert(temp,hat)
			end
		
		end
	end
	
	if #temp > 0 then 
		local back = string.Implode("$",temp)
		GAMEMODE:DropHat(pl)
		pl.SelectedHat = back
		GAMEMODE:SpawnHat(pl,back)
	end
	
	
	-- if pl:Team() ~= TEAM_HUMAN then return end
	-- if not pl:GetItemsDataTable()[itemID] then return end
	
	
	-- Does it exist? Is it a valid hat type? Did he buy it? Is it an admin-only hat?	
		--[==[if hats[hat] and (not ValidEntity(pl.Hat) or pl.Hat:GetHatType() ~= hat) and pl:Team() == TEAM_HUMAN 
			and pl:GetItemsDataTable()[itemID] and (not shopData[itemID].AdminOnly or pl:IsAdmin()) then
			GAMEMODE:DropHat(pl)
			pl.SelectedHat = hat
			GAMEMODE:SpawnHat(pl,hat)
		end]==]
end
concommand.Add("mrgreen_hat_set",SetPlayerHat) 

function SetPlayerSuit(pl,commandName,args)

	local hat = args[1]
	local itemID = util.GetItemID( hat )

	if suits[hat] and (not ValidEntity(pl.Suit) or pl.Suit:GetHatType() ~= hat) and pl:Team() == TEAM_HUMAN 
		and pl:GetItemsDataTable()[itemID] and (not shopData[itemID].AdminOnly or pl:IsAdmin()) then
		GAMEMODE:DropSuit(pl)
		pl.SelectedSuit = hat
		pl:ConCommand("_zs_defaultsuit "..tostring(hat))
		GAMEMODE:SpawnSuit(pl,hat)
	end

end
concommand.Add("mrgreen_suit_set",SetPlayerSuit) 

function DropPlayerHat(pl,commandName,args)
	GAMEMODE:DropHat(pl)
	GAMEMODE:DropSuit(pl)
	pl.SelectedHat = "none"
end
concommand.Add("mrgreen_hat_drop",DropPlayerHat) 

function DropPlayerSuit(pl,commandName,args)
	GAMEMODE:DropSuit(pl)
	pl.SelectedSuit = "none"
	pl:ConCommand("_zs_defaultsuit "..pl.SelectedSuit)
end
concommand.Add("mrgreen_suit_drop",DropPlayerSuit) 

function UnlockEventHat(pl)
	if pl:HasBought("wbeanie") then
		return
	end
	
	pl.DataTable.ShopItems[64] = true
	pl:SaveShopItem( 64 )
	stats.SendShopData( pl, pl )
	
	pl:ChatPrint("Congratulations! You have unlocked Winter Beanie hat in the shop!")
end

function BuyItem(pl,commandName,args)
	if not pl:IsValid() then return end
	
	local item = tonumber( args[1] )

	if not shopData[item] then return end
	if shopData[item].Hidden then return end

	local gc = pl:GreenCoins()
	
	-- voornamelijk protectie tegen mensen die direct via console items pogen aan te schaffen
	if gc < shopData[item].Cost then
		pl:ChatPrint("You're too poor you lazy bastard.")
		return
	end
	if shopData[item].AdminOnly and not pl:IsAdmin() then
		pl:ChatPrint("Server-side validation bitch!")
		return
	end
	if pl:GetItemsDataTable()[item] then
		pl:ChatPrint("You already have this item!")
		stats.SendShopData( pl, pl )
		return
	end
	if (shopData[item].Requires and pl.TotalUpgrades < shopData[item].Requires) or (shopData[item].NeedUpgrade and pl.TotalUpgrades >= shopData[item].Requires and not pl:HasBought(shopData[item].NeedUpgrade)) then
		if not pl:HasBought(shopData[item].NeedUpgrade) then
			pl:ChatPrint ("You need "..shopData[shopData[item].NeedUpgrade].Name.." to buy this item!")
		else
			pl:ChatPrint ("You need "..shopData[item].Requires.." more upgrades to buy this item!")
		end			
		return
	end

	--  buy the thing
	pl:TakeGreenCoins( shopData[item].Cost )
	pl.DataTable.ShopItems[item] = true
	
	--  Register in the DB
	pl:SaveShopItem( item )
	
	--  increment pl.TotalUpgrades
	if shopData[item].Cost > 2500 then
		pl.TotalUpgrades = pl.TotalUpgrades + 1
		GAMEMODE:SendUpgradeNumber ( pl )
	end

	stats.SendShopData( pl, pl )
	
	umsg.Start("CoinEffect",pl)
		umsg.Short(-shopData[item].Cost)
	umsg.End()
	
	if item == 27 then
		umsg.Start( "removeOptions",pl )
		umsg.End()
	end
end
concommand.Add("mrgreen_buyitem",BuyItem) 

function SellItem(pl,commandName,args)
	if not pl:IsValid() then return end
	local item = args[1]
	if not shopData[item] then return end
	
	pl:ChatPrint("Selling items disabled")
	-- voornamelijk protectie tegen mensen die direct via console items pogen aan te schaffen
	--[==[
	if shopData[item].AdminOnly and not pl:IsAdmin() then
		pl:ChatPrint("Server-side validation bitch!")
		return
	end
	if shopData[item].Sell < 1 then
		pl:ChatPrint("You can't sell this item!")
		return
	end
	if not pl.DataTable["shopitems"][item] then
		pl:ChatPrint("You don't got this item!")
		SendShopData(pl) -- update just in case
		return
	end
	
	-- sell the thing
	pl.GreenCoins = pl.GreenCoins + shopData[item].Sell
	pl.DataTable["shopitems"][item] = false
	
	GAMEMODE:SendCoins(pl)
	SendShopData(pl)
	
	--  Substract total upgrades!
	if shopData[item].Cost > 2500 then
		pl.TotalUpgrades = pl.TotalUpgrades - 1
		GAMEMODE:SendUpgradeNumber (pl)
	end
	
	umsg.Start("CoinEffect",pl)
		umsg.Short(shopData[item].Sell)
	umsg.End()
	
	if item == "titlechanging" then
		umsg.Start("removeOptions",pl)
		umsg.End()
	end]==]
end
concommand.Add("mrgreen_sellitem",SellItem) 

-- Set title
function SetPlayerTitle(pl,commandName,args)
	local title = args[1]
	
	if not ValidTitle(pl, title) then
		pl:ChatPrint("Invalid title!")
		return
	end
	
	if pl.LastTChange and pl.LastTChange > CurTime()-5 then
		pl:ChatPrint("Please wait 5 seconds before setting a new title")
		return
	end
	
	pl.LastTChange = CurTime()
	
	pl.Title = title
	GAMEMODE:SendTitle({pl},player.GetAll())
end
concommand.Add("mrgreen_settitle",SetPlayerTitle) 

-- Ban player
function BanPlayer(pl,commandName,args)
	if args[2] == nil then return end
	if not (pl:IsAdmin()) then return end
	if not (args[3]) then args[3] = "The admin did not give a ban reason." end
	
	for k=1, 3 do -- spam the command
		--pl:ConCommand("banid2 "..tonumber(args[1]).." "..tonumber(args[2]).."\n") 
		pl:ConCommand("sm_ban \""..tonumber(args[1]).."\" "..tonumber(args[2]).." \""..args[3].."\"\n") 
	end
	
end
concommand.Add("ban_player",BanPlayer) 

-- Kick player
function KickPlayer(pl,commandName,args)
	if args[1] == nil then return end
	if not (pl:IsAdmin()) then return end
	if not (args[2]) then args[2] = "The admin did not give a kick reason." end
	--args[2] = string.Replace(args[2]," ","_")
	for k=1, 3 do -- spam the command
		pl:ConCommand("kickid2 \""..tonumber(args[1]).."\" \""..args[2].."\"\n")
	end
	
end
concommand.Add("kick_player",KickPlayer) 

function SlayPlayer(pl,commandName,args)

	if not (pl:IsAdmin()) then return end
	if not (args[1]) then return end
	GetPlayerByUserID(tonumber(args[1])):Kill()
end
concommand.Add("slay_player",SlayPlayer)

function RedeemPlayer(pl,commandName,args)
	if not (pl:IsSuperAdmin()) then return end
	if not (args[1]) then return end
	GetPlayerByUserID(tonumber(args[1])):Redeem( pl )
end
concommand.Add("redeem_player",RedeemPlayer)

--Supply Crates count
function CountSupplyCrates(pl,commandName,args)
	if not (pl:IsAdmin()) then return end

	local CrateEntsCount = #ents.FindByClass("spawn_ammo")
	pl:ChatPrint("There are ".. tostring(CrateEntsCount) .." Supply Crates active")
end
concommand.Add("admin_countcrates",CountSupplyCrates)

-- Bring player
function BringPlayer(pl,commandName,args)

	if not (pl:IsAdmin()) then return end
	local target = GetPlayerByUserID(tonumber(args[1]))
	local des = pl
	
	if target == -1 or target == -2 then
		pl:PrintMessage(HUD_PRINTTALK, "Multiple or no players specified!")
		return
	end
	
	if not (des:Alive()) then
		pl:PrintMessage(HUD_PRINTTALK, "You're dead dumbass!")
		return
	end
	
	if not (target:Alive()) then
		pl:PrintMessage(HUD_PRINTTALK, "Specified player is not alive!")
		return
	end
	
	if (target == des) then
		pl:PrintMessage(HUD_PRINTTALK, "You can't bring yourself!")
		return			
	end
	
	local newpos = playerSend( target, des, target:GetMoveType() == MOVETYPE_NOCLIP )
	if not newpos then
		pl:PrintMessage( HUD_PRINTTALK, "Can't find a place to put them!")
		return
	end

	local newang = (des:GetPos() - newpos):Angle()

	target:SetPos( newpos )
	target:SetEyeAngles( newang )
	target:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!
	
	target:PrintMessage( HUD_PRINTTALK, "You were brought to (ADMIN) "..pl:Name())
	des:PrintMessage( HUD_PRINTTALK, "Player "..target:Name().." teleported to you")
	
end
concommand.Add("bring_player",BringPlayer) 

-- Unstuck script ! FULLY WORKING!
function PlayerStuck (pl,commandName,args)
	if not pl:IsValid() then return end
	if ENDROUND then return end
	if not pl:IsStuck( pl:GetPos() ) then pl:PrintMessage(HUD_PRINTTALK, "You are not stuck! Abusing this command will result in a kick/ban!") return end -- (pl:IsInWorld() and pl:IsOnGround()) or pl:Crouching() then pl:PrintMessage(HUD_PRINTTALK, "You are not stuck!") return end

	if pl:Team() == TEAM_UNDEAD and pl:GetZombieClass() == 10 then
		pl:PrintMessage(HUD_PRINTTALK, "This command isn't available as a crow!")
		return
	end
	
	local teleportto = pl
	local myteam = pl:Team()
	local pos = pl:GetPos()
	
	local newpos = false
	--keep searching for more and more until you find the perfect site and break.
	for i = 1,5 do
		for k,v in pairs (ents.FindInBox ( Vector (pos.x - (250*i),pos.y - (250*i),pos.z), Vector (pos.x + (250*i), pos.y + (250*i), pos.z + 300) )) do
			if string.find (v:GetClass(), "prop") then
				newpos = playerSend( pl,v,pl:GetMoveType() == MOVETYPE_NOCLIP )
				if newpos ~= false and not pl:IsStuck ( newpos ) then
					break
				end
			end
		end
		
		if newpos ~= false then
			break
		end
	end
	
	--- If there still isn't a position then go to players!
	if not newpos then
		for _,target in pairs (team.GetPlayers (myteam)) do
			if target:IsValid() and target:Alive() and target ~= pl and not newpos then
				if target:IsAdmin() then 
					teleportto = target
					newpos = playerSend( pl,teleportto,pl:GetMoveType() == MOVETYPE_NOCLIP )
				end
				
				if newpos == false then
					teleportto = target
					newpos = playerSend( pl,teleportto,pl:GetMoveType() == MOVETYPE_NOCLIP )
				end
			end
		end
	end
	
	-- Damn :(
	if not newpos then pl:PrintMessage (HUD_PRINTTALK,"Unstuck failed. Please try again!") return end
	local newang = (pl:GetPos() - newpos):Angle()

	pl:SetPos( newpos )
	pl:SetEyeAngles( newang )
	pl:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!
	
	pl:PrintMessage( HUD_PRINTTALK, "You were unstuck!")
	pl.StuckTimer = CurTime() + 20
end
concommand.Add("PlayerStuck",PlayerStuck) 

-- Goto player
function GotoPlayer(pl,commandName,args)

	if not (pl:IsAdmin()) then return end
	local target = pl
	local des = GetPlayerByUserID(tonumber(args[1]))
	
	if des == -1 or des == -2 then
		pl:PrintMessage(HUD_PRINTTALK, "Multiple or no players specified!")
		return
	end
	
	if not (des:Alive()) then
		pl:PrintMessage(HUD_PRINTTALK, "Specified player is not alive!")
		return
	end
	
	if not (target:Alive()) then
		pl:PrintMessage(HUD_PRINTTALK, "You're dead dumbass!")
		return
	end
	
	if (target == des) then
		pl:PrintMessage(HUD_PRINTTALK, "You can't goto yourself!")
		return			
	end
	
	local newpos = playerSend( target, des, target:GetMoveType() == MOVETYPE_NOCLIP )
	if not newpos then
		pl:PrintMessage( HUD_PRINTTALK, "Can't find a place to put you! Use noclip to force a goto.")
		return
	end

	local newang = (des:GetPos() - newpos):Angle()

	target:SetPos( newpos )
	target:SetEyeAngles( newang )
	target:SetLocalVelocity( Vector( 0, 0, 0 ) ) -- Stop!
	
	target:PrintMessage( HUD_PRINTTALK, "Teleported to player "..target:Name())
	
end
concommand.Add("goto_player",GotoPlayer) 

-- Change map
function ChangeMap(pl,commandName,args)

	if not (pl:IsAdmin()) then return end
	for k=1, 3 do
		game.ConsoleCommand("changelevel "..args[1].."\n")
	end
	
end
concommand.Add("change_map",ChangeMap) 

--Remove
function AdminRemove(pl,cmd,args)
	if not (pl:IsAdmin()) then return end
	
	local tr = pl:GetEyeTrace()
	
	if tr.Hit and tr.Entity and ValidEntity(tr.Entity) and not tr.Entity:IsPlayer() and not tr.Entity.AmmoCrate then
		tr.Entity:Remove()
		for k, v in pairs( player.GetAll() ) do
			v:CustomChatPrint( {nil, Color(255,0,0),"[ADMIN] ", Color(245,245,255),"Admin ",Color(255,0,0),tostring ( pl:Name() ),Color(235,235,255)," removed entity ",Color(255,255,255),tostring(tr.Entity:GetClass()).." !"})
		end
	end
	
end
concommand.Add("mrgreen_admin_remove",AdminRemove)

function ShowLevelStats (pl, cmd, args)
	if not (pl:IsValid() and pl:Alive()) then
		return
	end
	
	pl:PrintMessage(HUD_PRINTTALK,"Your rank is "..pl:GetRank() .." with "..pl:GetXP().."/"..pl:NextRankXP() .." XP.")
end
concommand.Add("zs_showlevel",ShowLevelStats)

function ShowClassDescription (pl, cmd ,args)
	if not (pl:IsValid() and pl:Alive()) then return end
	
	if pl:IsZombie() then
	pl:SendLua("MakeZClassInfo()")
	return
	end
	
	local leveladd = 1
	local pllevel = pl:GetHumanClass()
		
	if pl:GetTableScore(string.lower(HumanClasses[pl:GetHumanClass()].Name),"level") <= 6 then 
		leveladd = 1
	else
		leveladd = 0
	end
	
	if pllevel == 2 then
		lastdesc = ""
	else
		lastdesc = HumanClasses[pllevel].Coef[4]*(pl.DataTable["ClassData"][string.lower(HumanClasses[pllevel].Name)].level + leveladd)
	end
	
	--  Don't use /n. It will screw the custom chat bot formatting
	pl:PrintMessage (HUD_PRINTTALK, "Class description: Only For Humans!")
	pl:PrintMessage (HUD_PRINTTALK, HumanClasses[pllevel].Coef[1]*(pl.DataTable["ClassData"][string.lower(HumanClasses[pllevel].Name)].level + leveladd).." "..HumanClasses[pllevel].Description[1] )
	pl:PrintMessage (HUD_PRINTTALK, HumanClasses[pllevel].Coef[2]*(pl.DataTable["ClassData"][string.lower(HumanClasses[pllevel].Name)].level + leveladd).." "..HumanClasses[pllevel].Description[2] )
	pl:PrintMessage (HUD_PRINTTALK, HumanClasses[pllevel].Coef[3]*(pl.DataTable["ClassData"][string.lower(HumanClasses[pllevel].Name)].level + leveladd).." "..HumanClasses[pllevel].Description[3] )
	pl:PrintMessage (HUD_PRINTTALK, lastdesc.." "..HumanClasses[pllevel].Description[4] )
end
concommand.Add("show_classdescription",ShowClassDescription)

function RollTheDice ( pl,commandName,args )
	if ENDROUND then
		return
	end

	if not (pl:IsValid() and pl:Alive() and not ENDROUND) then
		return
	end
	
	if ServerTime() < (WARMUPTIME+10) then
		pl:ChatPrint("Dice temporarily disabled at round start")
		return
	end
	
	if pl.LastRTD >= CurTime() then
		pl:PrintMessage(HUD_PRINTTALK, "You have to wait "..math.floor((pl.LastRTD-CurTime())).." more seconds before you can roll the dice!")
		return
	end
	
	if pl:Team() == TEAM_UNDEAD then
		pl:ChatPrint("Roll the Dice is only available for humans.")
		return
	end
	
	local choise,message,name
	
	--Let's roll
	choise = math.random(1,5)
	
	--Second roll when having ladyluck-item
	if pl:HasBought("ladyluck") and choise <= 2 then
		choise = math.random(1,5)
	end
	
	message = pl:GetName()
	
	if choise == 1 then
		pl:GodDisable() -- no spawnprotection can save you now!
		local Ent = ents.Create("env_explosion")
		Ent:SetPos(pl:GetPos())
		Ent:Spawn()
		Ent:Activate()
		Ent:SetKeyValue("iMagnitude", 0) -- No actual explosion damage
		Ent:SetKeyValue("iRadiusOverride", 1)
		Ent:Fire("explode", "", 0)
		pl:SetVelocity( Vector(0,0,400) )
		pl:TakeDamage( pl:Health()*2, nil, nil ) -- make sure he dies
		message = message .." rolled the dice and is turned inside out!"
	elseif choise == 2 then
		pl:SetHealth(1)
		message = message .." rolled the dice and got raped in the ass."
	elseif choise == 3 then
		pl:GiveAmmo( 20, "pistol" )	
		pl:GiveAmmo( 60, "ar2" )
		pl:GiveAmmo( 50, "SMG1" )	
		pl:GiveAmmo( 15, "buckshot" )		
		pl:GiveAmmo( 5, "XBowBolt" )
		pl:GiveAmmo( 5, "357" )
		message = message .." rolled the dice and received some ammo!"	
	elseif choise == 4 and pl:Health() < pl:GetMaximumHealth() then
		local calchealth = math.Clamp ( 100 - pl:Health(),25,100 )
		local randhealth = math.random( 25, math.Round ( calchealth ) )
		pl:SetHealth( math.min( pl:Health() + randhealth, pl:GetMaximumHealth() ) )
		message = message .." rolled the dice and gained ".. randhealth .." health!"
	else
		pl:SetFrags(math.min(2048,pl:Frags()+150))
		message = message .." rolled the dice and received 150SP."
	end
	
	pl.LastRTD = CurTime() + RTD_TIME

	PrintMessageAll( HUD_PRINTTALK, message )
end
concommand.Add("zs_rollthedice",RollTheDice) 

function ShowShop(pl,commandName,args)
	-- pl:SendLua("MakepShop()")
	pl:SendLua("DrawGreenShop()")
end
concommand.Add("open_shop",ShowShop)

--[=[------------------------------------------
			Some extra functions
------------------------------------------]=]

function GetPlayerByUserID( id )
	for k, v in pairs(player.GetAll()) do
		if v:UserID() == id then
			return v
		end
	end
end

-- ulx player teleportation code
function playerSend( from, to, force )

	if not to:IsInWorld() and not force then return false end -- No way we can do this one

	local yawForward = to:EyeAngles().yaw
	local directions = { -- Directions to try
		math.NormalizeAngle( yawForward - 180 ), -- Behind first
		math.NormalizeAngle( yawForward + 90 ), -- Right
		math.NormalizeAngle( yawForward - 90 ), -- Left
		yawForward
	}

	local t = {}
	t.start = to:GetPos() + Vector( 0, 0, 32 ) -- Move them up a bit so they can travel across the ground
	t.filter = { to, from }

	local i = 1
	t.endpos = to:GetPos() + Angle( 0, directions[ i ], 0 ):Forward() * 47 -- (33 is player width, this is sqrt( 33^2 * 2 ))
	local tr = util.TraceEntity( t, from )
    while tr.Hit do -- While it's hitting something, check other angles
    	i = i + 1
    	if i > #directions then  -- No place found
			if force then
				return to:GetPos() + Angle( 0, directions[ 1 ], 0 ):Forward() * 47
			else
				return false
			end
		end

		t.endpos = to:GetPos() + Angle( 0, directions[ i ], 0 ):Forward() * 47

		tr = util.TraceEntity( t, from )
    end

	return tr.HitPos
	
end

--[==[------------------------------------
	Print message to all players
------------------------------------]==]

HUD_PRINTADMINCHAT = 77 -- custom printtype
function PrintMessageAll( printtype, text )

	if (printtype == HUD_PRINTADMINCHAT) then
		for k,v in pairs(player.GetAll()) do
			if (v:IsAdmin()) then
				v:PrintMessage(HUD_PRINTTALK,text)
			end
		end	
	else
		for k,v in pairs(player.GetAll()) do
			v:PrintMessage(printtype,text)
		end
	end
	
end

local clientCommandList = {      -- list of all client commands I added
"\nLIST OF COMMANDS FOR CLIENTS\n",
"BOOM \t\t\t\t- If you're a Chemical Zombie, you explode - OBSOLETE",
"!commandlist / !cmdhelp \t- Prints this list of commands in console",
"!options \t\t\t- Opens settings menu where you can toggle screeneffects",
"!help	\t\t\t- Opens help and information menu",
"!shop  \t\t\t- Opens the Mr. Green shop",
"!class	\t\t\t- Opens zombie class selection menu",
"!score or not achievements \t- opens achievement menu",
"!server \t\t\t- Opens server info panel",
"!rules \t\t\t\t- Opens rules panel",
"!donate \t\t\t- Opens donate panel",
"!autoredeem \t\t\t- Switch autoredeem on/off.",
"!kill	\t\t\t- Suicide",
"!thetime \t\t\t- Display current system time",
"!steamid \t\t\t- Displays your Steam ID",
"!unique	\t\t\t- Displays your unique ID",
"!mapcycle \t\t\t- Prints the mapcycle in your console",
"!stopsounds \t\t\t- Stops all sounds and music that's currently playing",
"!rtd \t\t\t\t- Roll The Dice! See how much lady luck loves you.",
"!nextmap \t\t\t- Displays the next map",
"!currentmap \t\t\t- Displays the current map",
"!jetboom \t\t\t- Easter egg",
"!mrgreen \t\t\t- Easter egg",
"!ywa \t\t\t\t- Easter egg",
"!clavus \t\t\t- Easter egg",
"!mayco \t\t\t\t- Easter egg",
"!ratman \t\t\t- Easter egg",
"!prismaa \t\t\t- Easter egg",
"!deluvas \t\t\t- Easter egg"}
			
local adminCommandList = {      -- list of all admin commands I added
"\nLIST OF ADMIN-ONLY COMMANDS\n",
"!slay <player name> \t\t- slays the specified player",
"!slap <player name> <amount> \t- slaps the specified player with the <amount> of damage",
"!bring <player name> \t\t- brings the specified player",
"!goto <player name> \t\t- goto the specified player, use noclip if there's no space",
"!kick <player name> \t\t- kick the specified player",
"!sweplist \t\t\t- Prints the list of available sweps in the console",
"!changemap <map name> \t\t- Changes map",
"!swep <player name> <weapon name> \t- Gives the specified player the specified weapon.",
"!frag+ <player name> \t\t- Gives the specified player a frag. Will update weapon rewards, but won't redeem zombies.",
"!ammo+ <player name> \t\t- Gives the specified player 100 ammo for the weapon he/she is holding.",
"!hp+ <player name> \t\t- Restores 25 health for the specified player",
"!redeem <player name> \t\t- Redeemes the specified player (if zombie)",
"!ip <player name> \t\t- Displays the specified player's IP address",
"!randomslay \t\t\t- randomly slays a player, could be used in case there is no zombie",
"!ravebreak \t\t\t- ONLY USE WHEN IT'S FUNNY"}

--[==[-----------------------------------------
				CHATCOMMANDS
-----------------------------------------]==]

local function CommandSay(pl, text, teamonly)
	if text:sub(1,1) == "!" then
		if (text == "!kill" or text == "!suicide" or text == "!boom") then
			if pl:Alive() and not ENDROUND and GAMEMODE:CanPlayerSuicide(pl) then
				pl:Kill()
			else
				--Heads up!
				local suicidenote = { "You can't suicide now.","Suicide is not the answer."}
				if math.random(1,3) == 1 then
					pl:Notice(suicidenote[math.random(1,#suicidenote)],3, Color(255,10,10,255))
				end
			end

			return ""
		--Print list of available commands
		elseif (text == "!commandlist" or text == "!commands" or text == "!cmdhelp") then
			pl:PrintMessage(HUD_PRINTCONSOLE, "\n\nList of commands on the Mr. Green server\n")
			pl:PrintMessage(HUD_PRINTCONSOLE, "-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- /\n")
			for _, mrgreencmd in pairs(clientCommandList) do		
				pl:PrintMessage(HUD_PRINTCONSOLE, mrgreencmd.."\n")	 	 	
			end

			if pl:IsAdmin() then
				for _, mrgreencmd in pairs(adminCommandList) do		
					pl:PrintMessage(HUD_PRINTCONSOLE, mrgreencmd.."\n")	 	 	
				end
			end
			pl:PrintMessage(HUD_PRINTCONSOLE, "\n-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- /\n\n")
			pl:PrintMessage(HUD_PRINTTALK, "List of commands printed in console.")
			return ""
		--Simulate an action
		elseif (text:sub(1,4) == "/me ") then
			PrintMessageAll(HUD_PRINTTALK,pl:Name().." "..text:sub(5,string.len(text)))
			return ""
		elseif (text == "!nextmap") then
			if ENDROUND then
				PrintMessageAll(HUD_PRINTTALK,"Player "..pl:Name().." needs glasses")
			else
				PrintMessageAll(HUD_PRINTTALK,"The next map is "..GAMEMODE:GetMapNext())
			end
			return ""
		elseif (text == "!thetime") then
			pl:PrintMessage(HUD_PRINTTALK,"The server time is "..os.date("%X")..". The date is "..os.date("%x")..".")
			return ""
		elseif (text == "!currentmap") then
			PrintMessageAll(HUD_PRINTTALK, "The current map is ".. game.GetMap())
			return ""
		elseif (text == "!mapcycle" or text == "!maplist") then
			server_RunCommand(pl, "zs_print_mapcycle")
			return ""
		--[[if (text == "!reportbug") then
			server_RunCommand(pl, "open_bugpanel")
			return ""
		end]]
		elseif (text:sub(1,4) == "!rtd") then
			server_RunCommand(pl, "zs_rollthedice")
			return ""
		-- Level stats! :D
		elseif (text == "!levelstats") then
			server_RunCommand(pl, "zs_showlevel")
			return ""
		elseif (text == "!classinfo") then
			--server_RunCommand (pl,"show_classdescription")
			pl:PrintMessage(HUD_PRINTTALK,"Class info not available.")
			return ""
		elseif (text == "!stopsounds") then
			server_RunCommand(pl, "stopsounds")
			pl:PrintMessage(HUD_PRINTTALK,"Stopped sounds.")
			return ""
		elseif (text == "!help" or text == "!info") then
			if not ENDROUND then
				pl:SendLua("MakepHelp()")
			else
				pl:PrintMessage(HUD_PRINTTALK,"Can't open help screen at intermission.")
			end
			return ""
		elseif (text == "!achievements" or text == "!score") then
			--[[if not ENDROUND then
			pl:SendLua("MakepHelp("..(#HELP_TXT+1)..")")
			end]]
			pl:PrintMessage(HUD_PRINTTALK,"Command currently not available.")
			return ""
		elseif (text == "!server") then
			--[[if not ENDROUND then
			pl:SendLua("MakepHelp(5)")
			end]]
			pl:PrintMessage(HUD_PRINTTALK,"Command currently not available.")
			return ""
		elseif (text == "!rules") then
			--[[if not ENDROUND then
			pl:SendLua("MakepHelp(2)")
			end]]
			pl:PrintMessage(HUD_PRINTTALK,"Command currently not available.")
			return ""
		elseif (text == "!donate") then
			--[[if not ENDROUND then
				pl:SendLua("MakepHelp(5)")
			end]]
			pl:PrintMessage(HUD_PRINTTALK,"Command currently not available.")
			return ""
		elseif (text == "!shop") then
			if not ENDROUND then
				server_RunCommand(pl, "open_shop")
			end
			return ""
		elseif (text == "!autoredeem") then
			if pl.AutoRedeem then
				server_RunCommand(pl, "zs_autoredeem", 0)
			else
				server_RunCommand(pl, "zs_autoredeem", 1)
			end
			return ""
		elseif (text:sub(1,5) == "!ppon" or text:sub(1,6) == "!ppoff" or text == "!options" or text == "!grainoff" or text == "!grainon") then
			pl:SendLua("MakepOptions()")
			return ""
		elseif (text == "!jetboom") then
			pl:PrintMessage( HUD_PRINTCENTER, "JetBoom: as great in programming as he is unfriendly." )
		elseif (text == "!clavus") then
			pl:PrintMessage( HUD_PRINTCENTER, "Undead overlord!" )
		elseif (text == "!ywa") then
			pl:PrintMessage( HUD_PRINTCENTER, "Ywa FTW!" )
		elseif (text == "!mayco") then
			pl:PrintMessage( HUD_PRINTCENTER, "Mayco: Your friendly neighbourhood admin! He likes ducks and potatoes!" )
		elseif (text == "!mrgreen") then
			pl:PrintMessage( HUD_PRINTCENTER, "WWW.MRGREENGAMING.COM -- Your multiplayer community!" )
		elseif (text == "!ratman") then
			pl:PrintMessage( HUD_PRINTCENTER, "RatMan: ClavusElite's little bro..." )
		elseif (text == "!prismaa") then
			pl:PrintMessage( HUD_PRINTCENTER, "CRY SOME MOREEEEE" )
		elseif (text == "!deluvas") then
			pl:PrintMessage( HUD_PRINTCENTER, "EEENUUUF Deluvas is ENUUFF!" )
		elseif (text == "!hundred2") then
			pl:PrintMessage( HUD_PRINTCENTER, "Old ZS Veteran and ducttape enthousiast." )
		elseif (text == "!chainsaw") then
			pl:PrintMessage( HUD_PRINTCENTER, "GIVE HIM SOME ICETEA OR DIE!" )
		elseif (text == "!corby") then
			pl:PrintMessage( HUD_PRINTCENTER, "CRYPTIC METAPHOR! (from Gears of Awesome)" )
		elseif (text == "!necrossin") then
			pl:PrintMessage( HUD_PRINTCENTER, "There is nothing to hate, but the Hate itselves!" )
		elseif (text == "!howler") then
			pl:PrintMessage( HUD_PRINTCENTER, "Ywa sure likes 'em" )
		elseif (text == "!chicken") then
			pl:PrintMessage( HUD_PRINTCENTER, "CHICKEN SHIT. FAILED TO DELIVER! Poor Ywa D:" )
		elseif (text == "!requirements") then
			pl:PrintMessage( HUD_PRINTCENTER, "Requirements are supposed to be hard! Stop whining :O!" )
		elseif (text == "!steamid") then
			pl:PrintMessage( HUD_PRINTTALK, "Your Steam ID is "..pl:SteamID() )
		elseif (text == "!uniqueid") then
			pl:PrintMessage( HUD_PRINTTALK, "Your Unique ID is "..pl:UniqueID() )
		elseif (text == "!entowner") then
			if not pl:Team() == TEAM_HUMAN or not pl:Alive() then
				return ""
			end
			
			local trmine = pl:GetEyeTrace()
			if not trmine.Hit then
				return ""
			end

			if trmine.Entity:IsValid() and trmine.Entity:GetClass() == "mine" then
				pl:PrintMessage(HUD_PRINTTALK, "This entity belongs to ".. trmine.Entity:GetOwner():Name() ..".")
			end
		else
			local tbString = string.Explode( " ", text )

			if tbString[1] == "!votemute" or tbString[1] == "!votegag" or tbString[1] == "!zsvotemute" or tbString[1] == "!zsvotegag" then
				return Vote(pl,text)
			end
		end
	end

	--Open help menu on question
	if (string.lower(text:sub(1,6)) == "how to" or string.lower(text:sub(1,10)) == "how do you" or string.lower(text:sub(1,11)) == "how did you" or string.lower(text:sub(1,8)) == "how do i") then
		if not ENDROUND then
			if not pl.IsAsked then
				pl:SendLua("MakepHelp()")
				pl.IsAsked = true
			end
		end
	end
	
	--[[if (text == "medic!") and pl:Health() <=65 then
	if not pl:Team() == TEAM_HUMAN then return end
		for _,medic in pairs(player.GetAll()) do
			if pl:Team() == TEAM_HUMAN and medic:Team() == TEAM_HUMAN and medic:Alive() and medic:GetHumanClass() == 1 and pl ~= medic then
				medic:Message( ""..pl:Name().." needs healing!",1,"white" )
			end
		end
	end]]

	--WHAT DOES THE SCOUT SAY ABOUT HIS HORNYNESS LEVEL?
	local tocheck = string.lower(text)
	local hornytab = { "fuck", "horny", "ass", "bitch", "penis", "kitty", "pussy", "suck", "cock", "billy", "slut", "oh shi", "cum", "juice", "dick", "sex" }	
	for k, v in pairs(hornytab) do
		if string.find(tocheck,v) then
			pl.Hornyness = pl.Hornyness + 1
		end
	end

	--Check for voice commands	
	if pl:Team() == TEAM_HUMAN then
		local set = pl.VoiceSet or "male"
		pl.ChatScream = pl.ChatScream or 0
		if pl.ChatScream < CurTime() or pl:IsSuperAdmin() then
			for k, v in pairs (VoiceSets[set].ChatSounds) do
				if string.find(string.lower(text),k) then
					pl:EmitSound(v[math.random(1,#v)])
					pl.LastVoice = CurTime()
					pl.ChatScream = CurTime() + 10 -- 10 secs before we're allowed another scream, prevents spam
					break
				end	
			end
		end
	end
end
hook.Add("PlayerSay", "ChatCommands1", CommandSay)

--List of weapons available for admins
local weaponList = { "weapon_zs_annabelle","weapon_zs_grenadelauncher","weapon_zs_turretplacer","weapon_zs_shotgun","weapon_zs_syringe","weapon_zs_melee_crowbar", "weapon_zs_classic", "weapon_zs_melee_keyboard", "weapon_zs_usp", "weapon_zs_p228", "weapon_zs_combatknife",       -- list all weapons you can give
"weapon_zs_glock3", "weapon_zs_deagle", "weapon_zs_fiveseven", "weapon_zs_elites", "weapon_zs_magnum","weapon_zs_tmp", "weapon_zs_mp5", "weapon_zs_p90","weapon_zs_smg", "weapon_zs_ump", "weapon_zs_barricadekit",
"weapon_zs_crossbow", "weapon_zs_scout", "weapon_zs_aug", "weapon_zs_galil", "weapon_zs_ak47", "weapon_zs_m4a1",
"weapon_zs_m3super90", "weapon_zs_m1014", "weapon_zs_m249","weapon_zs_mine", "weapon_zs_sg552", "weapon_zs_famas", "weapon_zs_tools_torch", "weapon_zs_tools_supplies", "weapon_zs_tools_remote",
"weapon_zs_pulserifle", "weapon_zs_melee_keyboard", "weapon_zs_melee_katana", "weapon_zs_melee_sledgehammer", "weapon_zs_melee_pot", "weapon_zs_melee_axe", "weapon_zs_melee_keyboard", "weapon_zs_melee_fryingpan", "weapon_zs_melee_shovel", "weapon_zs_tools_hammer", "weapon_zs_melee_plank","weapon_zs_grenadelauncher","weapon_zs_boomstick","weapon_zs_melee_combatknife","weapon_zs_pickup_flare","weapon_zs_pickup_gascan","weapon_zs_pickup_gascan2","weapon_zs_pickup_gasmask","weapon_zs_pickup_propane","weapon_zs_tools_plank"}
--List of weapons only available to superadmins
local restrictedweaponList = { "dev_points", "admin_tool_remover", "admin_tool_sprayviewer", "admin_tool_igniter", "admin_tool_canister", "weapon_physgun", "admin_exploitblocker",
"weapon_physcannon"	}
		
local function AdminSay( pl, text, teamonly )
	if not pl:IsAdmin() then 
		return
	end
	
	if (text:sub(1,3) == "@@@") then
		text = string.gsub(text,"@@@","")
		PrintMessageAll( HUD_PRINTCENTER, text )
		return ""
	elseif (text:sub(1,2) == "@@") then
		text = string.gsub(text,"@@","")
		PrintMessageAll( HUD_PRINTTALK, text )
		return ""
	elseif (text:sub(1,1) == "@") then
		text = string.gsub(text,"@","")
		PrintMessageAll( HUD_PRINTADMINCHAT, "(ADMINCHAT) "..pl:Name()..": "..text )
		return ""
	end

	local sep = string.Explode(" ",text)
	
	if (text == "!sweplist") then   -- prints the list of available weapons
		pl:PrintMessage(HUD_PRINTCONSOLE, "\n\nList of weapons spawnable for the !swep command:\n")
		pl:PrintMessage(HUD_PRINTCONSOLE, "-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \n")
		for _, swep in pairs(weaponList) do		
			pl:PrintMessage(HUD_PRINTCONSOLE, swep.."\n")	 	 	
		end
		if pl:IsSuperAdmin() then
			for _, swep in pairs(restrictedweaponList) do		
				pl:PrintMessage(HUD_PRINTCONSOLE, swep.."\n")	 	 	
			end
		end
		pl:PrintMessage(HUD_PRINTTALK, "List of weapons printed in console.")
		return ""	
	elseif(text == "!randomslay") then
		local theList = team.GetPlayers(TEAM_HUMAN)
		
		local unluckydude = theList[math.random(1,#theList)]
		if ValidEntity(unluckydude) then
			unluckydude:Kill()
			
			PrintMessageAll(HUD_PRINTTALK,"The condemned player for The Undead is..."..unluckydude:Nick())
		end
		return ""
	elseif (sep[1] == "!nametrack") then
		pl:PrintMessage(HUD_PRINTTALK, "Checking player names, reporting changes in 15 seconds.")
		StartNameTrack(pl)
		timer.Simple(15,function()
			EndNameTrack(pl)
		end)
		return ""
	elseif (text == "!admin" or text == "!menu") then
		-- pl:SendLua("MakepHelp("..(#HELP_TEXT+4)..")")
		return ""
	elseif text == "!mapmanager" and pl:IsSuperAdmin() then
		pl:SendLua("OpenMapManager()")
		return ""
	elseif text == "!remove" and pl:IsSuperAdmin() then
		server_RunCommand(pl, "mrgreen_admin_remove")
		return ""
	elseif text == "!exploitblocker" and pl:IsSuperAdmin() then
		pl:Give("admin_exploitblocker")
		return ""
	elseif text == "!ravebreak" then
		if LASTHUMAN or ENDROUND then
			if not Raving then
				RaveBreak()
			else
				pl:ChatPrint("You're already raving dude.")
			end
			return text
		else
			pl:ChatPrint("Ravebreak not available at this time of round.")
			return ""
		end
	elseif (text:sub(1,5) == "!asay") then
		text = string.gsub(text,"!asay","")
		for k,pl in pairs (player.GetAll()) do
			pl:CustomChatPrint( {nil, Color(255,15,15),text} )
		end

		return ""
	end

	--Super Admin only commands	
	if pl:IsSuperAdmin() then
		--[[if (text == "!explode") then
			local tr = pl:TraceLine(100)
			local Ent = ents.Create("env_explosion")
			Ent:EmitSound( "explode_4" )		
			Ent:SetPos(spawnpos)
			Ent:Spawn()
			Ent:Activate()
			Ent:SetKeyValue("iMagnitude", 20)
			Ent:SetKeyValue("iRadiusOverride", 120)
			Ent:Fire("explode", "", 0)
			
			return ""
		end]]
		if text == "!endround" then
			if not ENDROUND then
				gamemode.Call( "OnEndRound", TEAM_HUMAN )
			end
			
			return ""
		elseif (sep[1] == "!achievement" or sep[1] == "!unlock") then
			if sep[2] and pl:GetAchievementsDataTable()[tostring(sep[2])] ~= nil then
				pl:UnlockAchievement(sep[2])
			else
				pl:ChatPrint("Specify a valid achievement to unlock.")
			end

			return ""
		elseif text == "!fuckme" then
			pl:SendLua("StalkerFuck(5)")
			return ""
		elseif text == "!ornament" then
			for k, v in pairs(ents.FindByClass("prop_dynamic_ornament")) do
				print(k..": Pos = "..tostring(v:GetPos()).."; Parent = "..v:GetParent():GetClass())
			end

			return ""
		elseif text == "!redeemall" then
			for k, v in pairs(team.GetPlayers(TEAM_UNDEAD)) do
				server_RunCommand (pl, "redeem_player",v:UserID() )
			end

			return ""
		elseif text == "!slayall" then
			for k, v in pairs(player.GetAll()) do
				if v ~= pl then
					server_RunCommand (pl, "slay_player",v:UserID() )
				end
			end

			return ""
		end
	end

	if (#sep > 1 and text:sub(1,1) == "!") then
		if (sep[1] == "!changemap" or sep[1] == "!changelevel") then
			server_RunCommand(pl, "change_map",sep[2] )
			return ""		
		end
		
		--[==[------ Player targeted commands -------]==]
		
		local target = GetPlayerByName(sep[2])
		if (target == -1) then
			pl:PrintMessage( HUD_PRINTTALK, "Target player was not found.")
			return ""
		elseif (target == -2) then
			pl:PrintMessage( HUD_PRINTTALK, "Multiple targets found, please refine your request.")
			return ""
		end
		
		--Kick command
		if(sep[1] == "!kick") then
			if pl:IsValid() and pl:IsPlayer() and (pl:Team() == TEAM_UNDEAD or pl:Team() == TEAM_HUMAN) then
				server_RunCommand(pl, "kick_player",target:UserID() )
				pl:PrintMessage( HUD_PRINTTALK, "Player "..target:Name().." was kicked.")
			else
				pl:PrintMessage( HUD_PRINTTALK, "Player "..target:Name().." is invalid (glitched) and can't be kicked.")
			end
			return ""
		--IP/Host output command
		elseif (sep[1] == "!ip") or (sep[1] == "!host") then
			pl:PrintMessage(HUD_PRINTTALK, "Player "..target:Nick().." IP address is ".. target:IPAddress())
			return ""
		end
		
		-- Check if he's alive
		if not target:Alive() or not target:IsValid() then
			pl:PrintMessage( HUD_PRINTTALK, "Target player is not alive.")
			return ""
		end
		
		--Redeem command
		if (sep[1] == "!redeem" and target:Team() == TEAM_UNDEAD) then	
			if (target == pl and not pl:IsSuperAdmin()) then
				pl:ChatPrint("You cannot redeem yourself.")
			else
				server_RunCommand (pl, "redeem_player", target:UserID())
				if not LASTHUMAN or not ENDROUND then
					pl:ChatPrint(target:GetName().." was redeemed")
				else
					pl:ChatPrint("You can't redeem at LastHuman or EndRound!")
				end
				target:ChatPrint("You are redeemed by (ADMIN) ".. pl:GetName())
			end
			return ""
		--Slay command
		elseif(sep[1] == "!slay") then
			server_RunCommand (pl, "slay_player", target:UserID() )
			pl:PrintMessage( HUD_PRINTTALK, "Player "..target:Name().." was killed.")
			target:PrintMessage( HUD_PRINTTALK, "Admin "..pl:Name().." killed you.")
			return ""
		elseif(sep[1] == "!mute") then	
		
			target:Mute()
			PrintMessageAll(HUD_PRINTTALK, "Admin ".. pl:Name() .." muted player "..tostring(target:Name())..".")
			return ""
		elseif(sep[1] == "!unmute") then	
		
			target:UnMute()
			PrintMessageAll(HUD_PRINTTALK, "Admin ".. pl:Name() .." unmuted player "..tostring(target:Name())..".")
			return ""
		elseif(sep[1] == "!gag") then	
		
			target:Gag()
			PrintMessageAll(HUD_PRINTTALK, "Admin ".. pl:Name() .." gagged player "..tostring(target:Name())..".")
			return ""
		elseif(sep[1] == "!ungag") then	
		
			target:UnGag()
			PrintMessageAll(HUD_PRINTTALK, "Admin ".. pl:Name() .." ungagged player "..tostring(target:Name())..".")
			return ""
		elseif(sep[1] == "!slap") then
			local slapdam = 10
			if sep[3] then
				slapdam = tonumber(sep[3])
			end
			if slapdam == nil then 
				slapdam = 5
			end
			target:TakeDamage(slapdam)
			target:EmitSound("ambient/voices/citizen_punches2.wav")
			target:SetVelocity(Vector(math.random(-10,10),math.random(-10,10),math.random(0,10)):GetNormal()*math.random(300,500))
			pl:PrintMessage( HUD_PRINTTALK, "Player "..target:Name().." was slapped with "..slapdam.." damage.")
			target:PrintMessage( HUD_PRINTTALK, "Admin "..pl:Name().." slapped you with "..slapdam.." damage.")
			return ""		
		elseif sep[1] == "!bring" then
			server_RunCommand (pl, "bring_player", target:UserID() )
			return ""
		elseif sep[1] == "!goto" then
			server_RunCommand (pl, "goto_player", target:UserID() )
			return ""
		elseif sep[1] == "!ammo+" and pl:IsSuperAdmin() then
			if not pl:IsSuperAdmin() then pl:PrintMessage( HUD_PRINTTALK, "Only Super Admins can use this command now!") return "" end
			pl:PrintMessage( HUD_PRINTTALK, "Player "..target:Name().." was given 100 ammo for his current weapon")
			if (target ~= pl) then
				target:PrintMessage( HUD_PRINTTALK, "(ADMIN) "..pl:Name().." gave you 100 ammo for your current weapon")
			end
			local ammotype = target:GetActiveWeapon():GetPrimaryAmmoType()
			if ammotype == "none" then 
				ammotype = "pistol" 
			end
			target:GiveAmmo(100,ammotype)
			return ""
		-- Give hp command
		elseif sep[1] == "!hp+" and pl:IsSuperAdmin() then
			pl:PrintMessage( HUD_PRINTTALK, "Player "..target:Name().." restored 25 health")
			if (target ~= pl) then
				target:PrintMessage( HUD_PRINTTALK, "(ADMIN) "..pl:Name().." gave you 25 health")
			end
			target:SetHealth(target:Health()+25)
			return ""
		-- Give frag command
		elseif (sep[1] == "!frag+" or sep[1] == "!kill+") and pl:IsSuperAdmin() then
			target:AddFrags(1) 
			pl:ChatPrint(target:GetName().." received a kill")
			target:ChatPrint("You were given one kill by (ADMIN) "..pl:GetName())
			return ""
		elseif sep[1] == "!swep" then -- gives the admin the ability to appoint a swep to a player     
			local weaponToGive = nil
			
			if sep[3] then
				local tab = {}
				table.Add(tab,weaponList)
				if pl:IsSuperAdmin() then
					table.Add(tab,restrictedweaponList)
				end
				for k, v in pairs(tab) do
					if (string.find(string.lower(v),string.lower(sep[3]))) then
						if weaponToGive ~= nil then 
							weaponToGive = nil
							break
						end
						weaponToGive = v
					end
				end
			end
			if not pl:IsSuperAdmin() and target == pl then pl:PrintMessage( HUD_PRINTTALK, "Only Super Admins can give other admins or self weapons!") return "" end
			
			if (weaponToGive ~= nil) then
				target:Give(weaponToGive)
				pl:ChatPrint(target:GetName().." was given "..weaponToGive)
				target:ChatPrint("You received "..weaponToGive.." from (ADMIN) "..pl:GetName())
			else
				pl:ChatPrint("No valid weapon or multiple weapons specified.")
			end
			return ""
		elseif (sep[1] == "!debug") then
			local str = "***DEBUG***\nName: "..target:Name().."\nSteamID: "..target:SteamID().."\nUniqueID: "..target:UniqueID().."\nUserID: "..target:UserID()
			str = str.."\nModel: "..target:GetModel().."\nPosition: "..tostring(target:GetPos()).."\nTeam: "..team.GetName(target:Team()).."\n***END DEBUG***"
			pl:PrintMessage(HUD_PRINTCONSOLE,str)
			pl:ChatPrint("Debug printed to console.")
			return ""
		end
		
	end
	
end
hook.Add("PlayerSay", "ChatCommands2", AdminSay)

function ApplyLoadout(pl, com, args)
	if not args or #args <= 0 or not ValidEntity(pl) then
		return
	end
	
	if not pl.Loadout then
		pl.Loadout = {}
	end
	
	for _, item in pairs(args) do
		if pl:HasUnlocked(item) then
			if string.sub(item, 1, 1) == "_" then
				pl:SetPerk(item)
			elseif string.sub(item, 1, 6) == "weapon" then
				table.insert(pl.Loadout,item)
			end
		end
	end
end
concommand.Add("_applyloadout",ApplyLoadout)

function ApplySkillShopItem(pl,com,args)
	if not args or #args <= 0 or not ValidEntity(pl) or not pl:IsNearCrate() then return end
	
	local weapon = args[1]
	
	local Automatic, Pistol, Melee = pl:GetAutomatic(), pl:GetPistol(), pl:GetMelee()
	
	if string.sub(weapon, 1, 6) == "weapon" then
		if GAMEMODE.HumanWeapons[weapon] and GAMEMODE.HumanWeapons[weapon].Price then
			if pl:Frags() >= GAMEMODE.HumanWeapons[weapon].Price then
				local StrCategory = GetWeaponCategory ( weapon )
				local StrWep = nil
				
				if StrCategory == "Automatic" then
					if Automatic then
						StrWep = Automatic
					end
				elseif StrCategory == "Pistol" then
					if Pistol then
						StrWep = Pistol
					end
				elseif StrCategory == "Melee" then
					if Melee then
						StrWep = Melee
					end
				end
				
				if StrWep then
					for i,j in pairs ( pl:GetWeapons() ) do
						if j:GetClass() == StrWep:GetClass() then
							pl:DropWeapon(j)
							break
						end
					end 
				end
				pl:Give(weapon)
				skillpoints.AddSkillPoints(pl,-1*GAMEMODE.HumanWeapons[weapon].Price)
			end
		end
	else
		if GAMEMODE.SkillShopAmmo[weapon] and GAMEMODE.SkillShopAmmo[weapon].Price then
			if pl:Frags() >= GAMEMODE.SkillShopAmmo[weapon].Price then
				-- check for tools
				if GAMEMODE.SkillShopAmmo[weapon].Tool then
					for i,j in pairs ( pl:GetWeapons() ) do
						if j:GetClass() == GAMEMODE.SkillShopAmmo[weapon].Tool then
							j:SetClip1(j:Clip1() + GAMEMODE.SkillShopAmmo[weapon].Amount )
							skillpoints.AddSkillPoints(pl,-1*GAMEMODE.SkillShopAmmo[weapon].Price)
							pl:EmitSound("items/ammo_pickup.wav") -- add missing sound
							break
						end
					end
				else
					pl:GiveAmmo( math.Clamp (GAMEMODE.SkillShopAmmo[weapon].Amount,1,1000) , weapon )
					skillpoints.AddSkillPoints(pl,-1*GAMEMODE.SkillShopAmmo[weapon].Price)
				end
				
			end
		end
	end
end
concommand.Add("_applyskillshopitem",ApplySkillShopItem)

local function RestartCommand( pl, cmd, args )
    RunConsoleCommand("changelevel", tostring(game.GetMap()))
end
concommand.Add( "zs_restartmap", RestartCommand )

----------------------------------------------------------------------------------------------

hook.Add( "Initialize", "OnInitialize", function()
	if IRC_RELAY_ENABLED then
		irc:Connect( IRC_RELAY_SERVER )
	else
		print("[IRC] Reconnect attempted but module is disabled")
	end
end )

hook.Add( "irc.OnConnect", "OnConnect", function() 
	irc:Register( IRC_RELAY_NICK )
end )

local reconnectTries = 3

hook.Add( "irc.OnConnectError", "OnConnectError", function( errorid )
	print( "[IRC] Error connecting to the IRC server!" )
	
	if ( reconnectTries >= 0 ) then
		timer.Simple( 1, function() 
			irc:Connect( IRC_RELAY_SERVER )
		end )
		reconnectTries = reconnectTries - 1
	end
end )

hook.Add( "irc.OnRegisterTimeout", "OnRegisterTimeout", function()
	if IRC_RELAY_ENABLED then
		Debug("[IRC] Attempting reconnect to ".. IRC_RELAY_SERVER)
		
		if ( reconnectTries >= 0 ) then
			timer.Simple( 1, function() 
				irc:Connect( IRC_RELAY_SERVER )
			end )
			reconnectTries = reconnectTries - 1
		end
	else
		Debug("[IRC] Reconnect attempted but IRC is disabled")
	end
end )

hook.Add( "irc.OnWelcome", "OnWelcome", function( response ) 
	Debug("[IRC] Looks like we've received a warm welcome")

	--Join default channel
	--irc:Join( "#mrgreen" )

	--Join relay channel
	irc:Join( IRC_RELAY_CHANNEL )

	--Output fancy map name
	if TranslateMapTable[ game.GetMap() ] then
		irc:Say( string.format( "5*** Travelled to %s", TranslateMapTable[ game.GetMap() ].Name ), IRC_RELAY_CHANNEL )
	end
end )

hook.Add( "irc.OnUserJoin", "OnUserJoin", function( user, channel ) 
	if channel ~= IRC_RELAY_CHANNEL then
		return
	end

	player.CustomChatPrint( { nil, 
		Color( 0, 255, 0 ), "(IRC) ",
		Color( 191,196,22 ), string.format( "%s ", user.Name ), 
		Color( 255,255,255 ), string.format( "has joined %s", channel )
	} )
end )

hook.Add( "irc.OnPublicMessage", "OnPublicMessage", function( message, user, channel ) 
	if channel ~= IRC_RELAY_CHANNEL then
		return
	end

	player.CustomChatPrint( { nil, 
		Color( 0, 255, 0 ), "(IRC) ",
		Color( 191,196,22 ), string.format( "%s: ", user.Name ), 
		Color( 255,255,255 ), string.format( "%s", message ) 
	} )
end )

hook.Add( "irc.OnUserPart", "OnUserJoin", function( user, channel ) 
	if channel ~= IRC_RELAY_CHANNEL then
		return
	end

	player.CustomChatPrint( { nil, 
		Color( 0, 255, 0 ), "(IRC) ",
		Color( 191,196,22 ), string.format( "%s ", user.Name ), 
		Color( 255,255,255 ), string.format( "has left %s", channel )
	} )
end )

hook.Add( "irc.OnUserQuit", "OnUserQuit", function( user, reason ) 
	if channel ~= IRC_RELAY_CHANNEL then
		return
	end

	player.CustomChatPrint( { nil, 
		Color( 0, 255, 0 ), "(IRC) ",
		Color( 191,196,22 ), string.format( "%s ", user.Name ), 
		Color( 255,255,255 ), " has quit" 
	} )
end )

hook.Add( "PlayerSay", "irc.PlayerSay", function( pl, text, team ) 
	if ( not team ) then
		irc:Say( string.format( " 07%s: %s", pl:Name(), text ), IRC_RELAY_CHANNEL )
	end
end )

hook.Add( "PlayerDisconnected", "irc.PlayerDisconnected", function( pl )
	if IsValid( pl ) then
		irc:Say( string.format( "2*** %s disconnected [%i/%i]", pl:Name(), #player.GetAll(), game.MaxPlayers() ), IRC_RELAY_CHANNEL )
	end
end )

hook.Add( "PlayerConnect", "irc.PlayerConnected", function( name, address ) 
	irc:Say( string.format( "3*** %s connected [%i/%i]", name, #player.GetAll(), game.MaxPlayers() ), IRC_RELAY_CHANNEL )	
end )
